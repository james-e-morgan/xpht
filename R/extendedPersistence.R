#' Extended Persistent Homology Transform
#'
#' The function [extendedPersistence()] computes the extended persistent
#'  extended persistent homology transform of the boundary curves of a two
#'  dimensional shape in a given number of directions.
#'
#' Given a disjoint collection of simple closed curves representing the
#'  boundaries of a two dimensional shape, compute the extended
#'  persistent homology transform of the shape in a given number of directions.
#'  We assume the points on each boundary curves are ordered and construct the
#'  one skeleton by adding an edge between each pair of consecutive vertices.
#'  This skeleton is used to compute the height filtration in a given direction
#'  and determine the lower neighbours of each vertex. The regular persistent
#'  homology of each curve is then computed by the union find algorithm and used
#'  to construct the extended persistent homology.
#'
#' @param bdryCurves A list containing points along the boundary curves of the
#'  image. The list must be structured as
#'  * `bdryCurves[[1]]` is a vector \eqn{(m,n)} where \eqn{m} is the number of
#'      anticlockwise curves and \eqn{n} is the number of clockwise curves.
#'  * `bdryCurves[[i]]` is a matrix containing the points on an anticlockwise
#'      curve for \eqn{2\leq i\leq m+1}.
#'  * `bdryCurves[[j]]` is a matrix containing the points on a clockwise curve
#'      for \eqn{m+2\leq j\leq n+1}.
#'  The length of the list must be \eqn{m+n+1}.
#' @param imgName A `string`` giving the name of the image.
#' @param nDirections An `int` giving the number of directions to use. This
#'  must be *positive and even*.
#' @param tolerance `numeric` parameter to control the noise from the image.
#'  If the distance between two adjacent vertices is less than this value, then
#'  any class generated by them will be ignored. The default value is
#'  \eqn{1/\sqrt{2}}.
#' @param collinearTol `numeric` parameter to control the tolerance when
#'  determining if three points are collinear. This is used when determining
#'  whether a vertex on a curve is a local minimum. The default value is `1e-8`.
#' @inheritParams extractBoundary
#' @return A list of length `nDirections` where the *i*-th entry is the extended
#'  persistence diagram in the *i*-th direction. Each diagram is a list of
#'  length five with names *"Name"*, *"Ord0"*, *"Rel1"*, *"Ess0"*,
#'  *"Ess1"*. The entry for `Name` is a string identifying the object and the
#'  direction used for the height filtration. The remaining entries are
#'  (possibly empty) matrices containing the points on the relevant diagram.
#' @export
extendedPersistence <- function(bdryCurves,
                                imgName,
                                nDirections,
                                tolerance = 1 / sqrt(2),
                                collinearTol = 1e-8,
                                saveOutput = FALSE,
                                outputDir = NULL,
                                fName = NULL,
                                verbose = TRUE) {
  if (saveOutput) {
    if (!dir.exists(outputDir)) {
      outputDir <- getwd()
      cat("Output directory doesn't exist. Saving to working directory.\n")
    }
    if (is.null(fName)) {
      fName <- readline(prompt = "Please provide a filename for save: ")
    }
    out_file <- paste(outputDir, "/", fName, ".RDS", sep = "")
  }
  if (nDirections < 2 || nDirections %% 2 == 1) {
    stop("Number of directions must be at least two and even")
  } else {
    directions <- t(sapply(1:nDirections, function(r) {
      c(
        cos(2 * pi * r / nDirections),
        sin(2 * pi * r / nDirections)
      )
    }))
    midpoint <- (nDirections / 2) + 1
  }

  x_diagram <- vector(mode = "list")

  skeleton <- parseSkeleton(bdryCurves)

  for (d in 1:(nDirections / 2)) {
    diagram_name <- paste(imgName, "-", toString(d), sep = "")

    dir_vector <- directions[d, ]

    n_components <- length(skeleton)
    persistence_diagram <- vector(mode = "list", length = n_components)

    for (i in 1:n_components) {
      skeleton_component <- skeleton[i][[1]]

      filtration <- computeHeightFiltration(
        curve = skeleton_component,
        direction = dir_vector
      )

      persistence_diagram[[i]] <- computeDiagram(
        filtration = filtration,
        direction = dir_vector,
        tolerance = tolerance,
        collinearTol = collinearTol
      )
    }
    extendedDiagram <- computeExtendedDiagram(
      persistence_diagram = persistence_diagram,
      n_components = n_components,
      diagram_name = diagram_name
    )
    class(extendedDiagram) <- "extendedPHT"
    x_diagram[[d]] <- extendedDiagram
  }

  for (d in midpoint:nDirections) {
    diagram_name <- paste(imgName, "-", toString(d), sep = "")
    neg_diagram.names <- c("Name", "Ord0", "Rel1", "Ess0", "Ess1")
    neg_diagram <- sapply(neg_diagram.names, function(x) NULL)

    neg_diagram[["Name"]] <- diagram_name
    k <- d - midpoint + 1

    neg_diagram[["Ord0"]] <- (-1) * x_diagram[[k]][["Rel1"]]
    neg_diagram[["Rel1"]] <- (-1) * x_diagram[[k]][["Ord0"]]
    neg_diagram[["Ess0"]] <- -matrix(x_diagram[[k]][["Ess0"]][, c(2, 1)],
      ncol = 2
    )

    if (length(x_diagram[[k]][["Ess1"]]) > 0) {
      neg_diagram[["Ess1"]] <- -matrix(x_diagram[[k]][["Ess1"]][, c(2, 1)],
        ncol = 2
      )
    } else {
      neg_diagram[["Ess1"]] <- vector()
    }
    class(neg_diagram) <- "extendedPHT"
    x_diagram[[d]] <- neg_diagram
  }

  if (saveOutput) {
    saveRDS(x_diagram, file = out_file)
    if (verbose) {
      cat("Successfully saved ", out_file, "\n", sep = "")
    }
  } else {
    if (verbose) {
      cat("Extended persistence diagrams successfully computed for",
        nDirections, "directions.\n",
        sep = " "
      )
    }
    return(x_diagram)
  }
}

#' Compute the Extended PHT for multiple images
#'
#' Runs [extendedPersistence()] on all .RDS files in a given directory.
#'
#' @inheritParams extendedPersistence
#' @inheritParams multiExtractBoundary
#' @return If `saveOutput = TRUE`, then the output of [extendedPersistence()]
#'  for each object will be saved in a separate file. If `saveOutput = FALSE`,
#'  then multiExtendedPersistence()] returns a list containing the extended
#'  persistence diagrams for each object in `inputDir`. The \eqn{i}-th entry in
#'  the list is the extended persistence diagrams for the \eqn{i}-th file in
#'  `inputDir`.
#' @seealso extendedPersistence()
#' @importFrom utils tail
#' @export
multiExtendedPersistence <- function(inputDir,
                                     nDirections,
                                     tolerance = 1 / sqrt(2),
                                     collinearTol = 1e-8,
                                     saveOutput = FALSE,
                                     outputDir = NULL,
                                     verbose = TRUE) {
  files <- list.files(
    path = inputDir,
    pattern = "*.RDS",
    full.names = TRUE,
    recursive = FALSE
  )

  if (saveOutput) {
    if (!dir.exists(outputDir)) {
      outputDir <- getwd()
      cat("Output directory doesn't exist. Saving to working directory.\n")
    }
  } else {
    extended_diagrams <- vector(mode = "list", length = length(files))
  }

  for (i in seq_along(files)) {
    f <- files[[i]]
    if (verbose) {
      cat("Commencing,", f, "\n", sep = " ")
    }

    fName <- tail(strsplit(strsplit(f, ".", fixed = TRUE)[[1]][1],
                    "/",
                    fixed = TRUE
                  )[[1]], n = 1)

    bdryCurves <- readRDS(f)

    if (saveOutput) {
      extendedPersistence(
        bdryCurves = bdryCurves,
        imgName = fName,
        nDirections = nDirections,
        tolerance = tolerance,
        saveOutput = TRUE,
        outputDir = outputDir,
        fName = fName,
        verbose = verbose
      )
    } else {
      extended_diagrams[[i]] <- extendedPersistence(
        bdryCurves = bdryCurves,
        imgName = fName,
        nDirections = nDirections,
        tolerance = tolerance,
        saveOutput = FALSE,
        verbose = verbose
      )
    }
  }

  if (saveOutput) {
    cat("All extended persistence diagrams saved in:\n",
        outputDir, "\n", sep = "")
  } else {
    cat("All extended persistence diagrams computed.\n")
    return(extended_diagrams)
  }
}

parseSkeleton <- function(bdryCurves) {
  complex <- vector(mode = "list")

  skeleton.names <- c("vertex", "edge", "coords")

  ac_curves <- bdryCurves[[1]][1]
  c_curves <- bdryCurves[[1]][2]
  n_curves <- ac_curves + c_curves

  for (i in 2:(n_curves + 1)) {
    curve <- bdryCurves[[i]]
    skeleton <- sapply(skeleton.names, function(x) NULL)

    if (all(curve[1, ] == curve[nrow(curve), ])) {
      np <- nrow(curve) - 1
    } else {
      np <- nrow(curve)
    }

    skeleton[["vertex"]] <- 1:np
    skeleton[["edge"]] <- vector()
    skeleton[["coords"]] <- vector()

    for (j in 1:(np - 1)) {
      skeleton[["coords"]] <- rbind(
        skeleton[["coords"]],
        curve[j, ]
      )
      skeleton[["edge"]] <- rbind(
        skeleton[["edge"]],
        c(j, j + 1)
      )
    }
    skeleton[["edge"]] <- rbind(
      skeleton[["edge"]],
      c(np, 1)
    )
    skeleton[["coords"]] <- rbind(
      skeleton[["coords"]],
      curve[np, ]
    )
    complex[[i - 1]] <- skeleton
  }

  return(complex)
}

computeHeightFiltration <- function(curve, direction) {
  filtration.names <- c("height", "lowerNbrs", "coords")
  filtration <- sapply(filtration.names, function(x) NULL)

  filtration[["coords"]] <- curve[["coords"]]

  filtration[["height"]] <- apply(
    curve[["coords"]], 1,
    function(v) dotProduct(v, direction)
  )

  n_vertices <- max(curve[["vertex"]])

  filtration[["lowerNbrs"]] <- vector(mode = "list", length = n_vertices)

  for (i in 1:n_vertices) {
    e <- curve[["edge"]][i, ]

    h_1 <- filtration[["height"]][e[1]]
    h_2 <- filtration[["height"]][e[2]]

    if (h_1 < h_2) {
      filtration[["lowerNbrs"]][[e[2]]] <- append(
        filtration[["lowerNbrs"]][[e[2]]],
        e[1]
      )
    } else if (h_1 == h_2) {
      # If two adjacent vertices have the same height, then the one with the
      # lower index is the lower neighbour
      if (e[1] < e[2]) {
        filtration[["lowerNbrs"]][[e[2]]] <- append(
          filtration[["lowerNbrs"]][[e[2]]],
          e[1]
        )
      } else {
        filtration[["lowerNbrs"]][[e[1]]] <- append(
          filtration[["lowerNbrs"]][[e[1]]],
          e[2]
        )
      }
    } else {
      filtration[["lowerNbrs"]][[e[1]]] <- append(
        filtration[["lowerNbrs"]][[e[1]]],
        e[2]
      )
    }
  }
  return(filtration)
}

dotProduct <- function(v_1, v_2) {
  return(sum(v_1 * v_2))
}

#' @importFrom utils head tail
computeDiagram <- function(filtration, direction, tolerance, collinearTol) {
  sorted_heights <- unique(sort(filtration[["height"]]))
  n_vertices <- length(filtration[["height"]])

  diagram.names <- c("finite", "finite_minimal", "extended", "extended_minimal")
  diagram <- sapply(diagram.names, function(x) NULL)

  parents <- vector(
    mode = "list",
    length = length(filtration[["height"]])
  )

  if (abs(max(sorted_heights) - min(sorted_heights)) > tolerance) {
    diagram[["extended"]] <- c(
      head(sorted_heights, 1),
      tail(sorted_heights, 1)
    )
  }

  for (h in sorted_heights) {
    h_vertices <- which(filtration[["height"]] == h)

    for (v in h_vertices) {
      if (is.null(filtration[["lowerNbrs"]][[v]])) {
        # The vertex v has no lower neighbours.
        parents[[v]] <- v
      } else {
        components <- sapply(
          filtration[["lowerNbrs"]][[v]],
          function(x) findParent(x, parents)
        )
        # ignore multiple paths to same parent
        components <- unique(components)

        if (length(components) == 1) {
          parents[[v]] <- components
        } else {
          birth_times <- sapply(
            components,
            function(x) filtration[["height"]][x]
          )
          min_birth_time <- min(birth_times)

          components <- sort(components)

          # If there are two candidates for the birth of a component,
          # we take the one with the lower index.
          # This is for consistency.
          count <- 0

          for (x in components) {
            h_x <- filtration[["height"]][x]
            if (h_x > min_birth_time) {
              if (h_x < h) {
                # Component born at height of x dies at
                # the current height h.
                if (abs(h_x - h) > tolerance) {
                  diagram[["finite"]] <- rbind(
                    diagram[["finite"]],
                    c(h_x, h)
                  )
                  # Check if vertex x is minimal
                  idxs <- (c(x - 2, x - 1, x) %% n_vertices) + 1
                  vertices <- matrix(
                    c(filtration[["coords"]][idxs[1], ],
                      filtration[["coords"]][idxs[2], ],
                      filtration[["coords"]][idxs[3], ]),
                    nrow = 3,
                    ncol = 2,
                    byrow = TRUE
                  )
                  heights <- c(
                    filtration[["height"]][idxs[1]],
                    filtration[["height"]][idxs[2]],
                    filtration[["height"]][idxs[3]]
                  )

                  diagram[["finite_minimal"]] <- append(
                    diagram[["finite_minimal"]],
                    testMinimality(
                      vertices = vertices,
                      heights = heights,
                      direction = direction,
                      collinearTol = collinearTol
                    )
                  )
                }
              }
            } else if (h_x == min_birth_time) {
              if (count == 0) {
                new_component <- x
                parents[[v]] <- new_component
                count <- 1
              } else {
                if (h_x < h) {
                  if (abs(h_x - h) > tolerance) {
                    diagram[["finite"]] <- rbind(
                      diagram[["finite"]],
                      c(h_x, h)
                    )
                    # Check if vertex x is minimal
                    idxs <- (c(x - 2, x - 1, x) %% n_vertices) + 1

                    vertices <- matrix(
                      c(filtration[["coords"]][idxs[1], ],
                        filtration[["coords"]][idxs[2], ],
                        filtration[["coords"]][idxs[3], ]),
                      nrow = 3,
                      ncol = 2,
                      byrow = TRUE
                    )
                    heights <- c(
                      filtration[["height"]][idxs[1]],
                      filtration[["height"]][idxs[2]],
                      filtration[["height"]][idxs[3]]
                    )
                    diagram[["finite_minimal"]] <- append(
                      diagram[["finite_minimal"]],
                      testMinimality(
                        vertices = vertices,
                        heights = heights,
                        direction = direction,
                        collinearTol = collinearTol
                      )
                    )
                  }
                }
              }
            }
          }
          # All components found are part of same connected component.
          # Update this information
          for (x in components) {
            parents[[x]] <- new_component
          }
        }
      }
    }
  }
  if (length(diagram[["extended"]]) == 2) {
    birth_point <- unique(sapply(
      unique(parents),
      function(x) findParent(x, parents)
    ))

    if (length(birth_point) > 1) {
      stop("Simple closed curve has more than one essential class.")
    }

    # Check if vertex x is minimal
    x <- birth_point[1]
    idxs <- (c(x - 2, x - 1, x) %% n_vertices) + 1
    vertices <- matrix(
      c(filtration[["coords"]][idxs[1], ],
        filtration[["coords"]][idxs[2], ],
        filtration[["coords"]][idxs[3], ]),
      nrow = 3,
      ncol = 2,
      byrow = TRUE
    )
    heights <- c(
      filtration[["height"]][idxs[1]],
      filtration[["height"]][idxs[2]],
      filtration[["height"]][idxs[3]]
    )

    diagram[["extended_minimal"]] <- testMinimality(
      vertices = vertices,
      heights = heights,
      direction = direction,
      collinearTol = collinearTol
    )
  }

  return(diagram)
}

findParent <- function(x,
                       parents) {
  if (parents[[x]] == x) {
    return(x)
  } else {
    px <- findParent(parents[[x]], parents)
    return(px)
  }
}

computeExtendedDiagram <- function(persistence_diagram,
                                   n_components,
                                   diagram_name) {
  ex_diagram.names <- c("Name", "Ord0", "Rel1", "Ess0", "Ess1")
  ex_diagram <- sapply(ex_diagram.names, function(x) NULL)

  ord_0 <- vector()
  rel_1 <- vector()
  ext_0 <- vector()
  ext_1 <- vector()

  ex_diagram[["Name"]] <- diagram_name
  for (i in 1:n_components) {
    diagram <- persistence_diagram[[i]]

    if (length(diagram[["finite"]]) > 0) {
      nFinite <- nrow(diagram[["finite"]])

      for (j in 1:nFinite) {
        if (diagram[["finite_minimal"]][j]) {
          ord_0 <- rbind(
            ord_0,
            diagram[["finite"]][j, ]
          )
        } else {
          rel_1 <- rbind(
            rel_1,
            rev(diagram[["finite"]][j, ])
          )
        }
      }
    }

    if (length(diagram[["extended"]]) > 0) {
      if (diagram[["extended_minimal"]]) {
        ext_0 <- rbind(
          ext_0,
          diagram[["extended"]]
        )
      } else {
        ext_1 <- rbind(
          ext_1,
          rev(diagram[["extended"]])
        )
      }
    }
  }
  ex_diagram[["Ord0"]] <- ord_0
  ex_diagram[["Rel1"]] <- rel_1
  ex_diagram[["Ess0"]] <- ext_0
  ex_diagram[["Ess1"]] <- ext_1

  return(ex_diagram)
}

testMinimality <- function(vertices,
                           heights,
                           direction,
                           collinearTol) {
  v_k <- vertices[2, ]
  v_prev <- vertices[1, ]
  v_next <- vertices[3, ]

  h_k <- heights[2]
  h_prev <- heights[1]
  h_next <- heights[3]

  if (h_k > h_prev || h_k > h_next) {
    return(FALSE)
  }

  if (abs(h_k - h_prev) <= collinearTol &&
        abs(h_k - h_next) <= collinearTol) {
    return(testNormalVector(v_k, v_next, direction))
  } else {
    P <- c(
      0.5 * (v_next[1] + v_prev[1]),
      0.5 * (v_next[2] + v_prev[2])
    )

    delta <- (v_next[1] - v_k[1]) * (P[2] - v_k[2]) -
      (v_next[2] - v_k[2]) * (P[1] - v_k[1])

    if (delta != 0) {
      return(delta > 0)
    } else {
      stop("Numerical error in minimality test.
            Could not determine minimality.")
    }
  }
}

testNormalVector <- function(v_1,
                             v_2,
                             direction) {
  normal_vect <- c(v_2[2] - v_1[2], v_2[1] - v_1[1]) * c(-1, 1)

  return(dotProduct(direction, normal_vect) > 0)
}
